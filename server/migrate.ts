import { db, pool } from "./db";
import { users, expenses, chatMessages } from "@shared/schema";
import { eq } from "drizzle-orm";
import bcrypt from "bcrypt";

export async function runMigration() {
  try {
    console.log("üöÄ Starting database migration...");

    // Create tables (Drizzle will handle this)
    console.log("‚úÖ Tables created successfully");

    // Seed initial data
    console.log("üå± Seeding initial data...");
    
    const fatherEmail = "nghiado@gmail.com";
    const motherEmail = "duytran@gmail.com";

    // Check if users already exist
    const existingFather = await db.select().from(users).where(eq(users.email, fatherEmail));
    const existingMother = await db.select().from(users).where(eq(users.email, motherEmail));

    let familyId = `family_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

    if (existingFather[0]) {
      familyId = existingFather[0].familyId || familyId;
      console.log("üë® Father user already exists");
    } else {
      const fatherPasswordHash = await bcrypt.hash("Nghia123", 10);
      await db.insert(users).values({
        email: fatherEmail,
        phone: "0901234567",
        password: fatherPasswordHash,
        fullName: "ƒê·ªó Ng·ªçc Nghƒ©a",
        role: "father",
        familyId,
      });
      console.log("üë® Father user created");
    }

    if (!existingMother[0]) {
      const motherPasswordHash = await bcrypt.hash("Duy123", 10);
      await db.insert(users).values({
        email: motherEmail,
        phone: "0907654321",
        password: motherPasswordHash,
        fullName: "Tr·∫ßn Tr√≠ Duy",
        role: "mother",
        familyId,
      });
      console.log("üë© Mother user created");
    } else {
      console.log("üë© Mother user already exists");
    }

    // Seed sample expenses
    const sampleExpenses = [
      // ƒÇn u·ªëng
      { description: "ƒêi ch·ª£ cu·ªëi tu·∫ßn", amount: "350000", category: "ƒÇn u·ªëng" },
      { description: "ƒÇn t·ªëi nh√† h√†ng gia ƒë√¨nh", amount: "450000", category: "ƒÇn u·ªëng" },
      { description: "Mua th·ª±c ph·∫©m si√™u th·ªã", amount: "280000", category: "ƒÇn u·ªëng" },
      { description: "U·ªëng c√† ph√™ v·ªõi b·∫°n", amount: "120000", category: "ƒÇn u·ªëng" },
      { description: "Mua b√°nh m√¨ s√°ng", amount: "50000", category: "ƒÇn u·ªëng" },
      
      // ƒê√°m c∆∞·ªõi
      { description: "M·ª´ng c∆∞·ªõi b·∫°n Minh", amount: "500000", category: "ƒê√°m c∆∞·ªõi" },
      { description: "Phong b√¨ c∆∞·ªõi ch·ªã Lan", amount: "300000", category: "ƒê√°m c∆∞·ªõi" },
      { description: "Ti·ªÅn m·ª´ng c∆∞·ªõi anh H√πng", amount: "800000", category: "ƒê√°m c∆∞·ªõi" },
      { description: "Qu√† c∆∞·ªõi b·∫°n Th·∫£o", amount: "200000", category: "ƒê√°m c∆∞·ªõi" },
      
      // H·ªçc t·∫≠p
      { description: "H·ªçc ph√≠ th√°ng 12", amount: "2000000", category: "H·ªçc t·∫≠p" },
      { description: "Mua s√°ch gi√°o khoa", amount: "250000", category: "H·ªçc t·∫≠p" },
      { description: "H·ªçc th√™m ti·∫øng Anh", amount: "1500000", category: "H·ªçc t·∫≠p" },
      { description: "ƒê·ªì d√πng h·ªçc t·∫≠p", amount: "180000", category: "H·ªçc t·∫≠p" },
      { description: "Ph√≠ thi IELTS", amount: "4500000", category: "H·ªçc t·∫≠p" },
      
      // Y t·∫ø
      { description: "Kh√°m b·ªánh ƒë·ªãnh k·ª≥", amount: "400000", category: "Y t·∫ø" },
      { description: "Mua thu·ªëc c·∫£m", amount: "150000", category: "Y t·∫ø" },
      { description: "Kh√°m rƒÉng", amount: "600000", category: "Y t·∫ø" },
      { description: "B·∫£o hi·ªÉm y t·∫ø", amount: "300000", category: "Y t·∫ø" },
      
      // Gi·∫£i tr√≠
      { description: "Xem phim r·∫°p", amount: "200000", category: "Gi·∫£i tr√≠" },
      { description: "Du l·ªãch ƒê√† N·∫µng", amount: "5000000", category: "Gi·∫£i tr√≠" },
      { description: "Karaoke v·ªõi b·∫°n", amount: "300000", category: "Gi·∫£i tr√≠" },
      { description: "Mua game online", amount: "100000", category: "Gi·∫£i tr√≠" },
      
      // Giao th√¥ng
      { description: "ƒê·ªï xƒÉng xe m√°y", amount: "200000", category: "Giao th√¥ng" },
      { description: "V√© xe bu√Ωt th√°ng", amount: "150000", category: "Giao th√¥ng" },
      { description: "Grab ƒëi l√†m", amount: "500000", category: "Giao th√¥ng" },
      { description: "S·ª≠a xe m√°y", amount: "800000", category: "Giao th√¥ng" },
      
      // Qu·∫ßn √°o
      { description: "Mua √°o s∆° mi", amount: "350000", category: "Qu·∫ßn √°o" },
      { description: "Mua gi√†y th·ªÉ thao", amount: "1200000", category: "Qu·∫ßn √°o" },
      { description: "May ƒëo vest", amount: "3000000", category: "Qu·∫ßn √°o" },
      
      // Gia d·ª•ng
      { description: "Mua n·ªìi c∆°m ƒëi·ªán", amount: "800000", category: "Gia d·ª•ng" },
      { description: "S·ª≠a ch·ªØa nh√†", amount: "2000000", category: "Gia d·ª•ng" },
      { description: "Mua t·ªß l·∫°nh", amount: "8000000", category: "Gia d·ª•ng" },
      
      // ƒê√°m ma
      { description: "Ph√∫ng ƒëi·∫øu b√°c H√πng", amount: "200000", category: "ƒê√°m ma" },
      { description: "Vi·∫øng tang c√¥ Lan", amount: "300000", category: "ƒê√°m ma" },
    ];

    // Check if expenses already exist
    const existingExpenses = await db.select().from(expenses).limit(1);
    
    if (existingExpenses.length === 0) {
      for (const exp of sampleExpenses) {
        await db.insert(expenses).values({
          description: exp.description,
          amount: exp.amount,
          category: exp.category,
          userId: "seed",
          familyId,
          isManualCategory: true,
        });
      }
      console.log("üí∞ Sample expenses created");
    } else {
      console.log("üí∞ Sample expenses already exist");
    }

    console.log("‚úÖ Migration completed successfully!");
    return { success: true, message: "Migration completed successfully" };

  } catch (error) {
    console.error("‚ùå Migration failed:", error);
    return { success: false, message: `Migration failed: ${error}` };
  } finally {
    await pool.end();
  }
}

// For Vercel API route
export default async function handler(req: any, res: any) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    const result = await runMigration();
    res.status(200).json(result);
  } catch (error) {
    res.status(500).json({ error: 'Migration failed' });
  }
}
